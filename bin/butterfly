#!/usr/bin/env ruby

require 'rubygems'
require 'optparse'
require 'rubigen'
require 'rubigen/scripts/generate'
require File.dirname(__FILE__) + "/../lib/butterfly"
require File.dirname(__FILE__) + "/../lib/options"

# defines some colors for a nice command-line output
PURPLE = "\033[0;35m"
BLUE   = "\033[0;34m"
WHITE  = "\033[0;37m"
RED    = "\033[0;31m"


### Set up generators

# get code generators
generators = Butterfly::CodeGenerators.new


### Parse options and arguments from command-line

# get options parser
parser = Butterfly::Options::Parser.new(generators)

# parse and get options
options = parser.parse(ARGV)


# After parsing the options,
#  * first argument should be <generator-group>
#  * second argument should be <generator-type>
#  * third argument should be a <project_name>
#
# If no argument is left, show a list of available generator-groups
if ARGV.empty?
  parser.show_groups
end


# If one argument is provided, regard it as the name of a generator-group.
# If the generator-group name is an existing generator-group, show a list of available generator-types 
if ARGV.length == 1
  
  generator_group = ARGV[0]
  
  if generators.names.include?(generator_group)
    parser.show_types(generator_group)
  else
    raise Butterfly::GeneratorError, "#{RED}generator group '#{generator_group}' does not exist.#{WHITE}" 
  end
  
end


# If two arguments are provided, regard the first as the name of a generator-group and the second as the name of a generator-type.
# If the generator-type name is an existing generator-type, ask for a project name 
if ARGV.length == 2
  generator_group = ARGV[0]
  generator_types = generators.types_of(generator_group)
  generator_type = ARGV[1]

  if generator_types.include?(generator_type)
    parser.ask_for_project(generator_group, generator_type)
  else
    raise Butterfly::GeneratorError, "#{RED}generator type '#{generator_type}' does not exist in generator group '#{generator_group}'.#{WHITE}" 
  end  

end


# If three arguments are provided, the first is the generator-group, the second the generator-type ans the thirs the project name.
generator_group = ARGV[0]
generator_type = ARGV[1]

# check if generator group exists
if !generators.names.include?(generator_group)
  raise Butterfly::GeneratorError, "#{RED}generator group '#{generator_group}' does not exist.#{WHITE}" 
end

# check if generator type exists
if !generators.types_of(generator_group).include?(generator_type)
  raise Butterfly::GeneratorError, "#{RED}generator type '#{generator_type}' does not exist in generator group '#{generator_group}'.#{WHITE}" 
end  

project_name = ARGV[2]


# DEBUG 
puts "generator group: #{generator_group}"
puts "generator type:  #{generator_type}"
puts "project name:    #{project_name}"
puts "options:         #{options}"



# Add only the code generator of the selected generator-group to the beginning of a list of sources.
# This is to make generator-types with the same name clear
RubiGen::Base.prepend_sources(generators.source_of(generator_group)) 


# DUBUGGING
#puts "Sources: #{RubiGen::Base.sources}"
#RubiGen::Base.sources.each do |s|
#  puts s.names(:visible)
#end


# generate code!
RubiGen::Scripts::Generate.new.run([project_name], :generator => generator_type, :backtrace => true)


# create an empty git repository and commit generated files
if options[:git] then
  require 'git'
  project_folder = File.join(Dir.pwd, project_name)
  g = Git.init(project_folder)
  g.add(project_folder)
  g.commit("beginning of #{project_name} project")
end



